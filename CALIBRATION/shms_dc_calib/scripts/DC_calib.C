//SHMS DC Calibration: Implementation
#include "DC_calib.h"
#include <iostream>
#include <fstream>
#include <iomanip>
#include <vector>

using namespace std;

//_____________________________________________________________
DC_calib::DC_calib(string a, TString b, const int c, Long64_t d, TString e)

  :spec(a),          //set spectrometer to 'HMS', or 'SHMS'  ex. DC_Calib(HMS, pdc_replay.C, 488, 50000)
   ifile_name(b),    //initialization list
   run_NUM(c),
   num_evts(d),
   pid(e)
{
  //Initialize pointers
  dir_log    = NULL;
  dir_log_name = NULL;
  tree       = NULL;
  in_file    = NULL;
  out_file   = NULL;
  main_dir   = NULL;
  plane_dt   = NULL;
  plane_dt_corr = NULL;
  cell_dt    = NULL;
  cell_dt_corr    = NULL;
  fitted_cell_dt = NULL;
  dt_vs_wire = NULL;
  dt_vs_wire_corr = NULL;

  entries                = NULL;
  t_zero                 = NULL;
  t_zero_err             = NULL;
  t_zero_final           = NULL;
  bin_max                = NULL;
  bin_maxContent         = NULL;
  time_max               = NULL;
  twenty_perc_maxContent = NULL;
  ref_time               = NULL;
  tZero_fit              = NULL;

  graph                  = NULL;
  gr1_canv               = NULL;
  


  
}


//____________________________________________________________
DC_calib::~DC_calib()
{
  cout << "calling the destructor " << endl;  
  delete dir_log;  dir_log = NULL;
  delete dir_log_name;  dir_log_name = NULL;
  delete in_file;  in_file  = NULL;
  delete out_file; out_file = NULL;             
  delete graph;    graph    = NULL;
  delete gr1_canv; gr1_canv = NULL;
  //Delete 1D Arrays pointers to free up 'heap' space
    
    delete [] dt_vs_wire; dt_vs_wire = NULL;
    delete [] dt_vs_wire_corr; dt_vs_wire_corr = NULL;
    delete [] plane_dt; plane_dt     = NULL;
    delete [] plane_dt_corr; plane_dt_corr = NULL;

    //free 2d dynamic array cell_dt[][]
    for(int ip = 0; ip<NPLANES; ip++) 
      { 
	delete [] entries[ip];
	delete [] t_zero[ip];
	delete [] t_zero_err[ip];
	delete [] t_zero_final[ip];
	delete [] cell_dt[ip]; 
	delete [] cell_dt_corr[ip]; 
	delete [] fitted_cell_dt[ip];
	delete [] bin_max[ip]; 
	delete [] bin_maxContent[ip]; 
	delete [] time_max[ip]; 
	delete [] twenty_perc_maxContent[ip]; 
	delete [] ref_time[ip];  
      }  
    
    delete [] entries;                     entries                = NULL;
    delete [] t_zero;                      t_zero                 = NULL;
    delete [] t_zero_err;                  t_zero_err             = NULL;
    delete [] t_zero_final;                t_zero_final           = NULL;
    delete [] cell_dt;                     cell_dt                = NULL;
    delete [] cell_dt_corr;                cell_dt_corr                = NULL;
    delete [] fitted_cell_dt;              fitted_cell_dt         = NULL;
    delete [] bin_max;                     bin_max                = NULL;
    delete [] bin_maxContent;              bin_maxContent         = NULL;
    delete [] time_max;                    time_max               = NULL;
    delete [] twenty_perc_maxContent;      twenty_perc_maxContent = NULL;
    delete [] ref_time;                    ref_time               = NULL;
  
}

//____________________________________________________________
void DC_calib::setup_Directory()
{

  
  if (spec == "HMS")
    {
     
      dir_log = Form("mkdir -p ./%s_DC_Log_%d/", spec.c_str(), run_NUM);

      //Check if directory exists
      if (system(dir_log) != 0) 
	{
	  cout << "Creating Directory to store HMS Calibration Results . . ." << endl; 
	  system(dir_log);  //create directory to log calibration results
	}


    }

  else if (spec == "SHMS")
    {
      
      dir_log = Form("mkdir -p ./%s_DC_Log_%d/", spec.c_str(), run_NUM);

      //Check if directory exists
      if (system(dir_log) != 0) 
	{
	  cout << "Creating Directory to store SHMS Calibration Results . . ." << endl; 
	  system(dir_log);  //create directory to log calibration results
	}
      
      
    }

}


//____________________________________________________________
void DC_calib::printInitVar()
{
  cout << "Initialization variables: \n"
    "Input File: " << ifile_name << "\n"
    "Run #: " << run_NUM << "\n"
    "Events: " << num_evts << endl;

  
}



//___________________________________________________________
void DC_calib::SetPlaneNames()
{
  
  DETECTOR = "dc";
 
  //initialize DC plane names
  if(spec=="SHMS")
    {
      offset = 0.0;
      max_wire_entry = 1000;
      SPECTROMETER = "P";
      spectre = "p";
   
      planes[0] = plane_names[0]="1u1",  nwires[0] = 107; 
      planes[1] = plane_names[1]="1u2",  nwires[1] = 107; 
      planes[2] = plane_names[2]="1x1",  nwires[2] = 79;
      planes[3] = plane_names[3]="1x2",  nwires[3] = 79; 
      planes[4] = plane_names[4]="1v1",  nwires[4] = 107; 
      planes[5] = plane_names[5]="1v2",  nwires[5] = 107; 
      planes[6] = plane_names[6]="2v2",  nwires[6] = 107;
      planes[7] = plane_names[7]="2v1",  nwires[7] = 107;
      planes[8] = plane_names[8]="2x2",  nwires[8] = 79;
      planes[9] = plane_names[9]="2x1",  nwires[9] = 79;
      planes[10] = plane_names[10]="2u2", nwires[10] = 107;
      planes[11] = plane_names[11]="2u1", nwires[11] = 107;
   
    }
      
  
  else if(spec=="HMS")
    {
      max_wire_entry = 1000;
      offset = 115.;   //wires 81-96
      // offset_1v2 = 109.9;   //49-65
      SPECTROMETER = "H";
      spectre="h";
      
      planes[0] = plane_names[0]="1u1",  nwires[0] = 96;  
      planes[1] = plane_names[1]="1u2",  nwires[1] = 96;
      planes[2] = plane_names[2]="1x1",  nwires[2] = 102;
      planes[3] = plane_names[3]="1x2",  nwires[3] = 102; 
      planes[4] = plane_names[4]="1v2",  nwires[4] = 96;
      planes[5] = plane_names[5]="1v1",  nwires[5] = 96;
      planes[6] = plane_names[6]="2v1",  nwires[6] = 96;
      planes[7] = plane_names[7]="2v2",  nwires[7] = 96;
      planes[8] = plane_names[8]="2x2",  nwires[8] = 102;
      planes[9] = plane_names[9]="2x1",  nwires[9] = 102;
      planes[10] = plane_names[10]="2u2", nwires[10] = 96;
      planes[11] = plane_names[11]="2u1", nwires[11] = 96;
    }
  
}


//____________________________________________________________________________________

void DC_calib::GetDCLeafs()
{
  cout << "DC_calib::GetDCLeafs " << endl;
 
  //open input root file
  in_file = new TFile(ifile_name, "READ" );
  
  //Get the tree
  tree = (TTree*)in_file->Get("T");
  
  Long64_t nentries = tree->GetEntries();
  if (num_evts == -1) num_evts = nentries;
  if (num_evts > nentries)
    {
      cout << "Number of entries entered: " << num_evts << " exeeds MAX number of entries: " << nentries << endl;
      cout << "Setting the number of entries to:  " << nentries  <<  endl;
     
      num_evts = nentries;
      
    }
  cout <<  "Events: " << num_evts << endl;

  //Loop over each plane
  for (int ip = 0; ip < NPLANES; ip++)
    {
      
      base_name = SPECTROMETER+"."+DETECTOR+"."+plane_names[ip];
      ndatatime = "Ndata."+base_name+".time";
      ndatawirenum = "Ndata."+base_name+".wirenum";
      drifttime = base_name+".time";
      wirenum = base_name+".wirenum";
      
      //Set Branch Address 
      tree->SetBranchAddress(wirenum, wire_num[ip]);   
      tree->SetBranchAddress(drifttime, drift_time[ip]);   
      tree->SetBranchAddress(ndatawirenum, &ndata_wirenum[ip]);
      tree->SetBranchAddress(ndatatime, &ndata_time[ip]);   
						     
    }
  
  
  if (spec=="SHMS")
    {
      cal_etot_leaf = "P.cal.etotnorm";
      cer_npe_leaf = "P.ngcer.npeSum";  
      EL_CLEAN_leaf = "T.shms.pEL_CLEAN_tdcTime";
      //EL_CLEAN_leaf = "T.coin.pEL_CLEAN_ROC2_tdcTime";
      
      //Check Branch Status
      status_cal = tree->GetBranchStatus(cal_etot_leaf);
      status_cer = tree->GetBranchStatus(cer_npe_leaf); 
      status_EL_clean = tree->GetBranchStatus(EL_CLEAN_leaf);
      status_EL_clean=kTRUE;
       status_cer=kTRUE;
     
      if ((!status_cal || !status_cer || !status_EL_clean) && (pid=="pid_elec" || pid=="pid_hadron"))
	{
	  cout << "*************ATTENTION!**************" << endl;
	  cout << "" << endl;
	  cout << " One or more of the following leafs " << endl;
	  cout << " is *NOT* present in current ROOTfile. " << endl;
	  cout << "1) " << cal_etot_leaf<< endl;
	  cout << "2) " << cer_npe_leaf << endl;
	  cout << "3) " << EL_CLEAN_leaf << endl;
	  cout << "" << endl;
	  cout << "Please add them if you want to make " << endl;
	  cout << "any cuts during calibration." << endl;
	  cout << "" << endl;
	  cout << "OR, set the pid flag in main_calib.C " << endl;
	  cout << "to pid_kFALSE" << endl;
	  cout << "             Exiting NOW!          " << endl;
	  cout << "*************************************" << endl;

	  exit (EXIT_SUCCESS);
	}
    
      else
	{
	  tree->SetBranchAddress(cal_etot_leaf, &cal_etot);
	  // tree->SetBranchAddress(cer_npe_leaf, &cer_npe);   
	  tree->SetBranchAddress(EL_CLEAN_leaf, &EL_CLEAN);
	}
	
    }

  else if (spec=="HMS")
    {
      cal_etot_leaf = "H.cal.etot";
      cer_npe_leaf = "H.cer.npeSum";  
      EL_CLEAN_leaf = "T.hms.hEL_CLEAN_tdcTime";
      //EL_CLEAN_leaf = "T.coin.hEL_CLEAN_ROC2_tdcTime";

      //Check Branch Status with Boolean
      status_cal = tree->GetBranchStatus(cal_etot_leaf);
      status_cer = tree->GetBranchStatus(cer_npe_leaf); 
      status_EL_clean = tree->GetBranchStatus(EL_CLEAN_leaf);

      if ((!status_cal || !status_cer || !status_EL_clean) && (pid=="pid_elec" || pid=="pid_hadron"))
	{
	  cout << "*************ATTENTION!**************" << endl;
	  cout << "" << endl;
	  cout << " One or more of the following leafs " << endl;
	  cout << " is *NOT* present in current ROOTfile. " << endl;
	  cout << "1) " << cal_etot_leaf<< endl;
	  cout << "2) " << cer_npe_leaf << endl;
	  cout << "3) " << EL_CLEAN_leaf << endl;
	  cout << "" << endl;
	  cout << "Please add them if you want to make " << endl;
	  cout << "any cuts during calibration." << endl;
	  cout << "" << endl;
	  cout << "OR, set the pid flag in main_calib.C "<< endl;
	  cout << "to: pid_kFALSE" << endl;
	  cout << "             Exiting NOW!          " << endl;
	  cout << "*************************************" << endl;
	  exit (EXIT_SUCCESS);
	}

      else
	{
	  tree->SetBranchAddress(cal_etot_leaf, &cal_etot);
	  tree->SetBranchAddress(cer_npe_leaf, &cer_npe);   
	  tree->SetBranchAddress(EL_CLEAN_leaf, &EL_CLEAN);
	}
 
      
    }


}

void DC_calib::AllocateDynamicArrays()
{
  cout << " AllocateDynamicArrays " << endl;

  dir_log = new char();
  dir_log_name = new char();
  
  //Allocate 1D dynamic arrays
  plane_dt      = new TH1F[NPLANES];       //create plane drift time histo 1Darray ( get_pdc_time_histo.C )
  plane_dt_corr = new TH1F[NPLANES];      //create plane drift times to store after applying tzero correction
  dt_vs_wire    = new TH2F[NPLANES];     //create wire drift time and 'drifttime vs wire' arrays
  dt_vs_wire_corr = new TH2F[NPLANES];

  //Allocate 2D dynamic arrays
  entries                 = new Int_t*[NPLANES];
  t_zero                  = new Double_t*[NPLANES];
  t_zero_err              = new Double_t*[NPLANES];
  t_zero_final            = new Double_t*[NPLANES];
  cell_dt                 = new TH1F*[NPLANES];     /*create array to store cell drift times*/    
  cell_dt_corr            = new TH1F*[NPLANES];
  fitted_cell_dt          = new TH1F*[NPLANES];     /*create array to store cell drift times*/    
  bin_max                 = new Int_t*[NPLANES];    /*Array to store the bin number corresponding to the drift time distribution peak*/
  bin_maxContent          = new Int_t*[NPLANES];    /*Array to store the content (# events) corresponding to the bin with maximum content*/
  time_max                = new Double_t*[NPLANES]; /*Array to store the x-axis(drift time (ns)) corresponding to bin_max*/
  twenty_perc_maxContent  = new Double_t*[NPLANES]; /*Array to store 20% of maximum bin content (peak)*/						     
  ref_time                = new Double_t*[NPLANES]; /*Array to store ref_time(time corresp. to 20% of peak) times for each sense wire*/                  
  
 
  for(int ip=0; ip<NPLANES; ip++)
    {
      entries[ip]                 = new Int_t[nwires[ip]]; 
      t_zero[ip]                  = new Double_t[nwires[ip]];
      t_zero_err[ip]              = new Double_t[nwires[ip]];
      t_zero_final[ip]            = new Double_t[nwires[ip]];
      cell_dt[ip]                 = new TH1F[nwires[ip]];
      cell_dt_corr[ip]            = new TH1F[nwires[ip]];
      fitted_cell_dt[ip]          = new TH1F[nwires[ip]];
      bin_max[ip]                 = new Int_t[nwires[ip]];                   
      bin_maxContent[ip]          = new Int_t[nwires[ip]];              
      time_max[ip]                = new Double_t[nwires[ip]];                 
      twenty_perc_maxContent[ip]  = new Double_t[nwires[ip]];   						     
      ref_time[ip]                = new Double_t[nwires[ip]];                    
    }
  
  
}

//_______________________________________________________________
void DC_calib::CreateHistoNames()
{
  cout << "CreateHistoNames  " << endl;
 
  for(int ip=0; ip<NPLANES; ip++)
    {
      
      //Set-Up plane drift time histo labels
      plane_dt_name  = plane_names[ip]+"_time"; 
      plane_dt_title = spec + " DC, Plane "+plane_names[ip]+" Drift Time";
      
      plane_dt[ip].SetName(plane_dt_name);
      plane_dt[ip].SetTitle(plane_dt_title);
      plane_dt[ip].SetBins(NBINS, MINBIN, MAXBIN);
      plane_dt[ip].SetXTitle("Drift Time (ns)");
      plane_dt[ip].SetYTitle("Number of Entries / 1 ns");

      
      plane_dt_name_corr  = plane_names[ip]+"corrected_time"; 
      plane_dt_title_corr = spec + " DC, Plane "+plane_names[ip]+" Corrected Drift Time";
      
      plane_dt_corr[ip].SetName(plane_dt_name_corr);
      plane_dt_corr[ip].SetTitle(plane_dt_title_corr);
      plane_dt_corr[ip].SetBins(NBINS, MINBIN, MAXBIN);
      plane_dt_corr[ip].SetXTitle("Drift Time (ns)");
      plane_dt_corr[ip].SetYTitle("Number of Entries / 1 ns");
      

      
      //Set-Up Drift Time vs. Wire Number Histos labels
      dt_vs_wire_name  = "dt_vs_wire_plane_"+plane_names[ip]; 
      dt_vs_wire_title = spec + " Drift Time vs. Wire: Plane "+plane_names[ip];
      
      dt_vs_wire[ip].SetName(dt_vs_wire_name);
      dt_vs_wire[ip].SetTitle(dt_vs_wire_title);
      dt_vs_wire[ip].SetBins(nwires[ip], 0., nwires[ip], NBINS, MINBIN, MAXBIN);
      dt_vs_wire[ip].SetXTitle("Wire Number");
      dt_vs_wire[ip].SetYTitle("Drift Time (ns) / 1 ns");  

      dt_vs_wire_corr[ip].SetName(dt_vs_wire_name);
      dt_vs_wire_corr[ip].SetTitle(dt_vs_wire_title);
      dt_vs_wire_corr[ip].SetBins(nwires[ip], 0., nwires[ip], NBINS, MINBIN, MAXBIN);
      dt_vs_wire_corr[ip].SetXTitle("Wire Number");
      dt_vs_wire_corr[ip].SetYTitle("Drift Time (ns) / 1 ns");  

      //Set-Up cell drift time histos names
      for (wire = 0; wire < nwires[ip]; wire++)
	{
	  cell_dt_name  = Form("Wire_%d", wire+1); 
	  cell_dt_title = spec + " DC Plane " +plane_names[ip] + Form(": Wire_%d", wire+1);
	  
	  cell_dt[ip][wire].SetName(cell_dt_name);
	  cell_dt[ip][wire].SetTitle(cell_dt_title);
	  cell_dt[ip][wire].SetBins(NBINS, MINBIN, MAXBIN);
	  cell_dt[ip][wire].SetXTitle("Drift Time (ns)");
	  cell_dt[ip][wire].SetYTitle("Number of Entries / 1 ns");	       

	  fitted_cell_dt_name  = Form("Wire_%d", wire+1); 
	  fitted_cell_dt_title = spec + " DC Plane " +plane_names[ip] + Form(": Wire_%d", wire+1);
	  
	  fitted_cell_dt[ip][wire].SetName(fitted_cell_dt_name);
	  fitted_cell_dt[ip][wire].SetTitle(fitted_cell_dt_title);
	  fitted_cell_dt[ip][wire].SetBins(200, MINBIN, MAXBIN);
	  fitted_cell_dt[ip][wire].SetXTitle("Drift Time (ns)");
	  fitted_cell_dt[ip][wire].SetYTitle("Number of Entries / 1 ns");

	  cell_dt_corr[ip][wire].SetName(cell_dt_name);
	  cell_dt_corr[ip][wire].SetTitle(cell_dt_title);
	  cell_dt_corr[ip][wire].SetBins(NBINS, MINBIN, MAXBIN);
	  cell_dt_corr[ip][wire].SetXTitle("Drift Time (ns)");
	  cell_dt_corr[ip][wire].SetYTitle("Number of Entries / 1 ns");

	}
      
    }

}
  

//________________________________________________________________
void DC_calib::EventLoop()
{
  cout << " Eventloop " << endl;
  Int_t cnts_ch1=0;
  Int_t cnts_ch2=0;
  Bool_t good_event=kFALSE;
  Int_t ngood_events=0;
  //Loop over all entries
  for(Long64_t i=0; i<num_evts; i++)
    {
      //cout << "entry: " << i << endl;
      tree->GetEntry(i);
      if (i%20000==0) cout <<" Event = " << i << " Number of good events = " << ngood_events << endl;
      cnts_ch1 = 0;
      cnts_ch2 = 0;
      for (Int_t ip=0;ip<NPLANES;ip++) {
	if (ip<=5 && ndata_time[ip]==1) cnts_ch1++;
	if (ip>5 && ndata_time[ip]==1) cnts_ch2++;
      }
      good_event = kFALSE;

      //------READ USER 'pid' input to determine particle type to calibrate----------
      
      //NO PID Cut,
      if(pid=="pid_kFALSE")
	{
	  //cal_elec = 1;
	  cer_elec = 1;    
	  elec_clean = 1;     
	}

      //PID Cut, Set Bool_t to actual leaf value, and see if it passes cut
      else if (pid=="pid_elec")
	{
	  //cal_elec = cal_etot>0.1;  //normalize energy > 0.1 (bkg cleanup)
	  cer_elec = cer_npe>1.0;     //number of photoelec. > 1 (electrons)
	  elec_clean = EL_CLEAN>0;    //tdcTime>0 (reduce bkg events)
	  good_event= cal_etot > 0.5 &&  cnts_ch1>4 &&  cnts_ch1>5;
	}

      //PID Cut, hadron, Set Bool_t to actual value, and see if it passes cut
      else if (pid=="pid_hadron")
	{
	  //cal_elec = cal_etot>0.1;  //normalize energy > 0.1 (bkg cleanup)
	  cer_elec = cer_npe<1.0;      //number of photoelec. < 1 (hadrons)
	  elec_clean = 1;    //set always to true (NOT use e-_clean trigger cut)
	}

      //PID Cut, BACKGROUND, Set Bool_t to actual value, and see if it passes cut
      else if (pid=="dc_1hit")
	{

	  //Do NOT apply any pid cuts
	  cer_elec = 1;      //Set to always true
	  elec_clean = 1;    //Set to always true
	  
	}

      

      else 
	{
	  cout << "Enter which particle to calibrate in main_calib.C: " << endl;
	  cout << "For electrons: 'pid_elec' " << endl;
	  cout << "For hadrons: 'pid_hadron' " << endl;	  
	  cout << "For background cut (ndata==1): 'dc_1hit' " << endl;
	  cout << "NO PID Cuts: 'pid_KFALSE' " << endl;
	  cout << "Exiting NOW!" << endl;
	  exit (EXIT_SUCCESS);
	}

      //----------------------------------------------------------------------------

      if (good_event) 
	
	{
	  ngood_events++; // cout << "passed cut: " << i << endl;
	  for(Int_t ip=0; ip<NPLANES; ip++)
	    {
	      // cout << "PLANE: " << ip << endl;

	      //-----------------------------------------------------------------------------------------	  
	      //Require single hit in chamber / event / plane
	       single_hit = ndata_wirenum[ip]==1 ;
	      //Require number of chamber hits per event per plane to be UNITY.
	      if (single_hit)
		{

        
		  //Loop over number of hits for each trigger in each DC plane 
		  for(Int_t k = 0; k < ndata_wirenum[ip]; k++)    
		    {
		      
		      
		      //get wire hit for ith event in 'ip' plane
		      wire = int(wire_num[ip][k]);
		      //cout << "event: " << i << " ::pEL-Clean: " << pEL_CLEAN << endl;
		      
		      
		      
		      //Fill uncorrected plane drift times  (from: get_pdc_time_histo.C )
		      if (ip== 0 && wire > 80)
			{
			  plane_dt[ip].Fill(drift_time[ip][k] - offset); 
			  dt_vs_wire[ip].Fill(wire_num[ip][k], drift_time[ip][k] - offset);
			  cell_dt[ip][wire-1].Fill(drift_time[ip][k] - offset);
			  fitted_cell_dt[ip][wire-1].Fill(drift_time[ip][k] - offset);
			}
		      
		      else if (ip== 6 && wire > 80)
			{
			  plane_dt[ip].Fill(drift_time[ip][k] - offset); 
			  dt_vs_wire[ip].Fill(wire_num[ip][k], drift_time[ip][k] - offset);
			  cell_dt[ip][wire-1].Fill(drift_time[ip][k] - offset);
			  fitted_cell_dt[ip][wire-1].Fill(drift_time[ip][k] - offset);
			}
		      
		      else if (ip == 0 && wire <= 80) 
			{
			  plane_dt[ip].Fill(drift_time[ip][k]); 
			  dt_vs_wire[ip].Fill(wire_num[ip][k], drift_time[ip][k]);
			  cell_dt[ip][wire-1].Fill(drift_time[ip][k]);
			  fitted_cell_dt[ip][wire-1].Fill(drift_time[ip][k]);
			}
		      else if (ip == 6 && wire <= 80) 
			{
			  plane_dt[ip].Fill(drift_time[ip][k]); 
			  dt_vs_wire[ip].Fill(wire_num[ip][k], drift_time[ip][k]);
			  cell_dt[ip][wire-1].Fill(drift_time[ip][k]);
			  fitted_cell_dt[ip][wire-1].Fill(drift_time[ip][k]);
			}
		      
		      
		      
		      else if ((ip == 4 || ip == 10) && wire > 48 && wire <65)
			{
			  plane_dt[ip].Fill(drift_time[ip][k] - offset); 
			  dt_vs_wire[ip].Fill(wire_num[ip][k], drift_time[ip][k] - offset);
			  cell_dt[ip][wire-1].Fill(drift_time[ip][k] - offset);
			  fitted_cell_dt[ip][wire-1].Fill(drift_time[ip][k] - offset);
			}
		      else if (ip == 4 && (wire <=48 || wire >= 65)) 
			{
			  plane_dt[ip].Fill(drift_time[ip][k]); 
			  dt_vs_wire[ip].Fill(wire_num[ip][k], drift_time[ip][k]);
			  cell_dt[ip][wire-1].Fill(drift_time[ip][k]);
			  fitted_cell_dt[ip][wire-1].Fill(drift_time[ip][k]);
			} 
		      else if (ip == 10 && (wire <= 48 || wire >= 65)) 
			{
			  plane_dt[ip].Fill(drift_time[ip][k]); 
			  dt_vs_wire[ip].Fill(wire_num[ip][k], drift_time[ip][k]);
			  cell_dt[ip][wire-1].Fill(drift_time[ip][k]);
			  fitted_cell_dt[ip][wire-1].Fill(drift_time[ip][k]);
			} 
		      
		      else if (ip!=4 || ip!=0 || ip!=6 || ip!=10)
			{
			  plane_dt[ip].Fill(drift_time[ip][k]); 
			  dt_vs_wire[ip].Fill(wire_num[ip][k], drift_time[ip][k]);
			  cell_dt[ip][wire-1].Fill(drift_time[ip][k]);
			  fitted_cell_dt[ip][wire-1].Fill(drift_time[ip][k]);
			} 
		    }//end loop over hits

		}// end if statement (require ONLY 1 hits per event)	 
//-----------------------------------------------------------------------------------------
	      
	    } //END loop over planes   
	
	} //end loop over pid cuts
    
    } //end loop over events

} // end event loop method


//_________________________________________________________________________
/*
void DC_calib::CalcT0Historical()
{
  //Loop over DC PLANES
  for (int ip = 0; ip<NPLANES; ip++)
    {
      //Loop over DC wires
      for (wire = 0; wire < nwires[ip]; wire++)
	{
	  double tempt0 = 0;

	  if (cell_dt[ip][wire].GetEntries()>500){
	    bin_max[ip][wire] = cell_dt[ip][wire].GetMaximumBin()+10;
	    double histMax = 0;
	    for (Int_t bin = 1; bin <= bin_max[ip][wire]+10; bin++){
	      double avgMax = 0;
	      double sumMax = 0;
	      int nseq = 0;
	      int nmin = bin+8;
	      
	      for (int ii = bin; ii<=nmin; ii++){
		double cc = cell_dt[ip][wire].GetBinContent(ii);
		if (cc>10){
		  sumMax += cc;
		  nseq++;
		}
	      }
	      
	      if (nseq>6){
		avgMax = sumMax/(double)nseq;
	      }
	      if (avgMax>histMax){
		histMax = avgMax;
	      }	   
	    }//end loop bins
	    twenty_perc_maxContent[ip][wire] = 0.2*histMax;
	    
	    //Use the 20% to find the t0 offset
	    for (Int_t bin = 10; bin <= MAXBIN-8; bin++){
	      double binMax = 0;
	      int nseq = 0;
	      int nmin = bin+8;
	      
	      for (int ii = bin; ii<=nmin; ii++){
		double cc = cell_dt[ip][wire].GetBinContent(ii);
		if (cc>twenty_perc_maxContent[ip][wire]){
		  nseq++;
		}
	      }
	      
	      if (nseq>7){
		int binRef = 0;
		cell_dt[ip][wire].GetBinWithContent(twenty_perc_maxContent[ip][wire], binRef, 1,bin_max[ip][wire],10.0);
		tempt0 = cell_dt[ip][wire].GetXaxis()->GetBinCenter(binRef);
		break;
	      }
	    }//end loop bins
	  }//end entries>500

	  t_zero[ip][wire] = tempt0;
	 
	}//end loop wires
    }//end loop planes
}
*/

//_________________________________________________________________________
void DC_calib::GetTwentyPercent_Peak()
{
  cout << " GetTwentyPercent " << endl;
  
  //Loop over DC PLANES
  for (int ip = 0; ip<NPLANES; ip++)
    {
      
      //Loop over DC wires
      for (wire = 0; wire < nwires[ip]; wire++)
	{
	 
	  bin_max[ip][wire]                = cell_dt[ip][wire].GetMaximumBin();                      //Get bin with Maximum Content
	  bin_maxContent[ip][wire]         = cell_dt[ip][wire].GetBinContent(bin_max[ip][wire]);	      //Get content of bin_max
	  time_max[ip][wire]               = cell_dt[ip][wire].GetXaxis()->GetBinCenter(bin_max[ip][wire]);  //Get time (ns) [x-axis] corresponding to bin_max 
	  twenty_perc_maxContent[ip][wire] = bin_maxContent[ip][wire] * 0.20;	                      
	  //Calculate 20% of max bin content
	  //ref_time[ip][wire] = cell_dt[ip][wire].GetBinCenter(cell_dt[ip][wire].FindBin(twenty_perc_maxContent[ip][wire]));
	  //Loop over DC drift time bins
	  for (Int_t bin = 1; bin <= bin_max[ip][wire]; bin++)
	    {
	      content_bin = cell_dt[ip][wire].GetBinContent(bin);              //get bin content for all bins in a wire
	      
	      content.push_back(content_bin);                                      //add bin content to array
	      bin_num.push_back(bin);                                              //add bin number to array
	      
	      // check if 2 bin contents have been stored and examine if these contents exceed or not 20% of peak
	      if (content.size() == 5) {
		//initialize counter to count how many bin contents >= 20%
		counts = 0;
		
		// Loop over 2 bin contents stored in array content
		for (Int_t j=0; j<5; j++)
		  {
		    if(content[j] >=  twenty_perc_maxContent[ip][wire])
		      {
			counts = counts+1;
			if(counts >= 4) { goto stop;}
		      }
		    
		    content.clear();
		    bin_num.clear();
		    
		  }
		
	      }
	      
	    }
	stop:
	  ref_time[ip][wire] = cell_dt[ip][wire].GetXaxis()->GetBinCenter(bin_num[0]); //Get time corresponding ~20% Max BIN CONTENT  
	  
	  
	}
      
    }
 
}


//____________________________________________________________________________________
void DC_calib::FitWireDriftTime()
{
  
  Double_t sum_NUM= 0.0;
  Double_t sum_DEN=0.0;




  //Loop over planes
  for (Int_t ip = 0; ip < NPLANES; ip++)
    {
      cout << "pLANE: " << ip << endl;
      //Loop over DC sense wires
      for (wire = 0; wire < nwires[ip]; wire++)
	{
	  //Get Bin no. associated with the reference time
	  binx = cell_dt[ip][wire].GetXaxis()->FindBin(ref_time[ip][wire]);
	  
	  //Get time corresponding to bin (fit range) 
	  time_init = cell_dt[ip][wire].GetXaxis()->GetBinCenter(binx - 10); //choose bin range over which to fit
	  time_final = cell_dt[ip][wire].GetXaxis()->GetBinCenter(binx + 10); 
	  
	  //Create Fit Function
	  tZero_fit = new TF1("tZero_fit", "[0]*x + [1]", time_init, time_final);
	  
	  //Set Parameter Names and Values
	  tZero_fit->SetParName(0, "slope");
	  tZero_fit->SetParName(1, "y-int");
	  tZero_fit->SetParameter(0, 1.0);
	  tZero_fit->SetParameter(1, 1.0);

	  entries[ip][wire] = fitted_cell_dt[ip][wire].GetEntries();

	  //Avoid mssg due to zero entries: Warning in <Fit>: Fit data is empty 
	  //	  if (entries[ip][wire] !=0)
	  //{
	      //Fit Function in specified range
	      fitted_cell_dt[ip][wire].Fit("tZero_fit", "QR");
	      //}
	      gStyle->SetOptFit(1);
	  //Get Parameters and their errors
	  m = tZero_fit->GetParameter(0);
	  y_int = tZero_fit->GetParameter(1);
	  m_err = tZero_fit->GetParError(0);
	  y_int_err = tZero_fit->GetParError(1);
	  std_dev = fitted_cell_dt[ip][wire].GetStdDev();

	  //Require sufficient events and NOT CRAZY! tzero values, otherwis, set t0 to ZERO
	  if (abs(-y_int/m) < std_dev*5.0 && m > 0.2 && entries[ip][wire]>max_wire_entry)
	    {
	      t_zero[ip][wire] = - y_int/m ;
	      t_zero_err[ip][wire] = sqrt(y_int_err*y_int_err/(m*m) + y_int*y_int*m_err*m_err/(m*m*m*m) );
	      //calculate the weighted average     
	      sum_NUM = sum_NUM + t_zero[ip][wire]/pow(t_zero_err[ip][wire],2);
	      sum_DEN = sum_DEN + 1.0/ (pow(t_zero_err[ip][wire],2));
	      //cout << "wire: " << wire + 1 << " :: " << "tzero: " << t_zero[ip][wire] << endl;
	    }

	 
	 
	    else if (abs(-y_int/m)>=5.0*std_dev ||  m <= 0.2  || entries[ip][wire] <= max_wire_entry)
		{
		  
		  t_zero[ip][wire] = 0.0;
		//if (ip==3) {
		//cout << "wire: " << wire <<  " t_zero_bad: " << t_zero[ip][wire] << endl;    
		 //cout << "m = " << m << " :: " << entries[ip][wire] << endl;
		//} 
		}	  

	} //END LOOP OVER WIRES

      weighted_avg[ip] = sum_NUM /sum_DEN; 
      
      //Set weighted averages to tzero[ip][wire]
      //Loop over wires to re-assign tzero per wires
      for (wire = 0; wire < nwires[ip]; wire++)
	{
	  if (t_zero[ip][wire] == 0.0)
	    {
	      t_zero[ip][wire] = weighted_avg[ip];
	      //cout << "bad wire: " << wire + 1 << " :: " << "tzero: " << weighted_avg[ip] << endl;
	    }
	}
      
      
    }//END LOOP OVER PLANES  

  
}


//________________________________________________________________
void DC_calib::Calculate_tZero()
{
  
  //CalcT0Historical();

  GetTwentyPercent_Peak();
  FitWireDriftTime();
}


//________________________________________________________________
void DC_calib::WriteToFile(Int_t debug = 0)
{

  
  //create output ROOT file to write UnCALIB./CALIB. histos
  ofile_name = "./"+spec+"_DC_Log_"+std::to_string(run_NUM) +"/"+spec+"_DC_driftimes.root";
  out_file   = new TFile(ofile_name, "RECREATE"); 

  
  //***NOTE***  debug = 0 (OFF), 1 (ON)
  //-------------------------------------------------------------------
  if (debug == 1) 
    {
      //------write uncorrected plane drift time histos to a directory on FILE--------
      main_dir = out_file->mkdir("uncorr_plane_times");   
      main_dir->cd();
      
      for(Int_t ip=0; ip<NPLANES; ip++)
	{
	  //write histos to root file
	  plane_dt[ip].Write();
	}

   //------write corrected plane drift time histos to a directory on FILE--------
      main_dir = out_file->mkdir("corr_plane_times");   
      main_dir->cd();
      
      for(Int_t ip=0; ip<NPLANES; ip++)
	{
	  //write histos to root file
	  plane_dt_corr[ip].Write();
		}

      
      

      
  //----------------------------------------------------------------------

  
  //--------write uncorrected cell drift times histos to FILE-------- 
   
  main_dir = out_file->mkdir("uncorr_wire_times");
  
    for (int ip=0; ip<NPLANES; ip++)
      {
	
	// create planes sub-directories to store wire drift times
	(main_dir->mkdir("plane "+plane_names[ip], ""))->cd();
	
	dt_vs_wire[ip].Write(); //write 2d drifttimet_vs_wire to FILE
	
	for (wire = 0; wire < nwires[ip]; wire++)
	  {
	    
	    cell_dt[ip][wire].Write();   //Write wire driftimes to FILE
	    
	  }
      
     } //END LOOP OVER PLANES

  //--------write corrected cell drift times histos to FILE-------- 
    
  main_dir = out_file->mkdir("corr_wire_times");
  
    for (int ip=0; ip<NPLANES; ip++)
      {
	
	// create planes sub-directories to store wire drift times
	(main_dir->mkdir("plane "+plane_names[ip], ""))->cd();
	
	dt_vs_wire_corr[ip].Write(); //write 2d drifttimet_vs_wire to FILE
	
	for (wire = 0; wire < nwires[ip]; wire++)
	  {
	    
	    cell_dt_corr[ip][wire].Write();   //Write wire driftimes to FILE
	    
	  }
      
      } //END LOOP OVER PLANES

    


 //------------------------------------------------------------------------

   //-------Write Fitted Wire Drift Time histos to FILE----------------------------
  

  main_dir = out_file->mkdir("fitted_wire_drift_times");
  
    for (int ip=0; ip<NPLANES; ip++)
      {
	
	// create planes sub-directories to store fitted wire drift times
	(main_dir->mkdir("plane "+plane_names[ip], ""))->cd();
		
	for (wire = 0; wire < nwires[ip]; wire++)
	  {
	    fitted_cell_dt[ip][wire].Write();   //Write wire driftimes to FILE
	    
	  }
      
      } //END LOOP OVER PLANES
  
    //-----Write 'tzero' values to a TEXT FILE--------------------
    
    //open a text FILE to write
    for (int ip = 0; ip < NPLANES; ip++) 
      {

	otxtfile_name = Form("./%s_DC_Log_%d/t_zero_values_%s.dat", spec.c_str(), run_NUM, planes[ip].c_str());
	cout << "*******FILENAME:******* " << otxtfile_name << endl;
	out_txtFILE.open(otxtfile_name);
	out_txtFILE << "#Plane_" + plane_names[ip] << endl;
	out_txtFILE << "#Wire " << setw(12) << "tzero " << setw(12) << "t_zero_err " << setw(12) << "entries" << endl;
	
	for (wire = 0; wire < nwires[ip]; wire++) 
	  {
	    out_txtFILE << wire+1 << "    " << t_zero[ip][wire] << "     " << t_zero_err[ip][wire] << "             " << entries[ip][wire] << endl;
	  }
	
	out_txtFILE.close();
      
      }
     
//------------------------------------------------------------------------
    
    main_dir = out_file->mkdir("t0_vs_wire");
    main_dir->cd();
    
    for (int ip=0; ip<NPLANES; ip++)
      {
	
	//fit_tzero[ip] = new TF1(Form("fit%d", ip), "pol0", 1, nwires[ip]);
	gr1_canv = new TCanvas("gr1", "", 2000, 500);
	gr1_canv->SetGrid();
	//write TGraph: tzero v. wire number to root file
	itxtfile_name =  "./"+spec+"_DC_Log_"+ std::to_string(run_NUM) +"/"+"t_zero_values_"+plane_names[ip]+".dat";
	graph = new TGraphErrors(itxtfile_name, "%lg %lg %lg");
	graph->SetName("graph");
	
	graph_title = "DC "+plane_names[ip]+": t0 vs. Wire";
	graph->SetTitle(graph_title);
	
	graph->SetMarkerStyle(20);
	graph->SetMarkerColor(1);
	
	graph->GetXaxis()->SetLimits(0., nwires[ip]);
	graph->GetXaxis()->SetTitle("Wire Number");
	graph->GetXaxis()->CenterTitle();
	graph->GetYaxis()->SetTitle("t-Zero (ns)");
	graph->GetYaxis()->CenterTitle();
	graph->GetYaxis()->SetRangeUser(-50.0, 50.0);
	
	graph->Draw("AP");
	gr1_canv->Update();
	gr1_canv->Write(graph_title);   //write to a root file
  
	  }
 
    } //END DEBUG   


}
  

//__________________________________________________________________________
void DC_calib::WriteTZeroParam()
{
  otxtfile_name =  "./"+spec+"_DC_Log_"+ std::to_string(run_NUM) +"/"+spectre+"dc_tzero_per_wire_"+std::to_string(run_NUM)+".param";
  out_txtFILE.open(otxtfile_name);
  
  for (int ip=0; ip<NPLANES; ip++) { 
	  
    //write plane headers
    out_txtFILE << spectre+"tzero"+plane_names[ip] << "=" << endl;

    //cout << "Plane: "  << ip << endl;
   for (wire=0; wire<nwires[ip]; wire++) 
     {
       //cout << "Plane: " << ip << " ::  wire: " << wire+1 << " :: " << "tzero_final: "<< t_zero_final[ip][wire] << endl;
       if (wire <= 10) 
	 { 
	   out_txtFILE << setprecision(6) << t_zero_final[ip][wire] << fixed << ",";
	 }
       else if (wire>10 && wire <(nwires[ip]-1))
	 {
	   out_txtFILE << setprecision(6) << t_zero_final[ip][wire] << ((wire+1) % 16 ? ", " : "\n") << fixed;
	 }
       else if (wire==nwires[ip]-1) 
	 {
	   out_txtFILE << setprecision(6) << t_zero_final[ip][wire] << fixed << endl;
	 }
       
     } //END LOOP OVER WIRES

  } //END LOOP OVER PLANES
  
  out_txtFILE.close();
  
}



//_______________________________________________________________________
void DC_calib::ApplyTZeroCorrection()
{
  
 
  cout << "ApplyT0Corr  "<< endl;

   Int_t cnts_ch1=0;
  Int_t cnts_ch2=0;
  Bool_t good_event=kFALSE;
 
  //Loop over all entries
  for(Long64_t i=0; i<num_evts; i++)
    {
      tree->GetEntry(i);
      if (i%20000==0) cout <<" Event = " << i << endl;
      cnts_ch1 = 0;
      cnts_ch2 = 0;
      for (Int_t ip=0;ip<NPLANES;ip++) {
	if (ip<=5 && ndata_time[ip]==1) cnts_ch1++;
	if (ip>5 && ndata_time[ip]==1) cnts_ch2++;
      }
      good_event = kFALSE;

      //----------READ USER 'pid' input to determine particle type to calibrate----------

      //PID Cut, Set Bool_t to always kTRUE
      if(pid=="pid_kFALSE")
	{
	  //cal_elec = 1;
	  cer_elec = 1;    
	  elec_clean = 1;    
	  
	}

      //PID Cut, Set Bool_t to actual value, and see if it passes cut
      else if (pid=="pid_elec")
	{
	  //cal_elec = cal_etot>0.1;   //normalize energy > 0.1 (reduce bkg events)
	  cer_elec = cer_npe>1.0;          //number of photoelec. > 1 (electrons)
	  elec_clean = EL_CLEAN>0.;    //tdcTime>0 (reduce bkg events)
	  good_event= cal_etot > 0.5 &&  cnts_ch1>4 &&  cnts_ch1>5;

	}

      //PID Cut, hadron, Set Bool_t to actual value, and see if it passes cut
      else if (pid=="pid_hadron")
	{
	  //cal_elec = cal_etot>0.1;   //normalize energy > 0.1 (reduce bkg events)
	  cer_elec = cer_npe<1.0;       //number of photoelec. < 1 (hadrons)
	  elec_clean = 1;    //Set always to true (do NOT make el-clean trigger cuts)
	  
	}

      //PID Cut, hadron, Set Bool_t to actual value, and see if it passes cut
      else if (pid=="dc_1hit")
	{
	  //cal_elec = cal_etot>0.1;   //normalize energy > 0.1 (reduce bkg events)
	  cer_elec = 1;       //set to always true
	  elec_clean = 1;    //tdcTime>0 (reduce bkg events)//set always to true
	  
	}
      

      else 
	{
	  cout << "Enter which particle to calibrate in main_calib.C: " << endl;
	  cout << "For electrons: 'pid_elec' " << endl;
	  cout << "For hadrons: 'pid_hadron' " << endl;	  
	  cout << "For background cut (Only ndata==1): 'dc_1hit' " << endl;
	  cout << "NO PID Cuts: 'pid_KFALSE' " << endl;
	  cout << "Exiting NOW!" << endl;
	  exit (EXIT_SUCCESS);
		  
	}

      //--------------------------------------------------------------------------------------
	  
      if (good_event) 
	{
	  
	  
	  for(Int_t ip=0; ip<NPLANES; ip++)
	    {
	      //cout << "ApplyTZeroCorr: " << weighted_avg[ip] << endl;
	      //Loop over number of hits for each trigger in each DC plane 

	      //Require single hit in chamber / event / plane
		  single_hit = ndata_wirenum[ip]==1;
	      
	      //-----------------------------------------------------------------------------------------	  
	      
	      //Require number of chamber hits per event per plane to be UNITY.
	      if (single_hit)
		{
		  for(Int_t k = 0; k < ndata_wirenum[ip]; k++)    
		    {
		      //get wire hit for ith event in 'ip' plane
		      wire = int(wire_num[ip][k]);
		      
		      //Apply general offsets to account for TDC shift
		      if (ip== 0 && wire > 80)
			{
			  //apply weighted average corr to low stats wires
			  if ( t_zero[ip][wire-1] == weighted_avg[ip])
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - offset - weighted_avg[ip]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - offset - weighted_avg[ip]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - offset - weighted_avg[ip]);	  
			      t_zero_final[ip][wire-1] = offset + weighted_avg[ip];
			      //cout << "offset: " << offset << endl;
			      //cout << "weighted avg: " << weighted_avg[ip] << endl;
			      //cout << "t_zero_final: " << t_zero_final[ip][wire-1] << endl;
			    }
			  
			  else 
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - offset - t_zero[ip][wire-1]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - offset - t_zero[ip][wire-1]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - offset - t_zero[ip][wire-1]);
			      t_zero_final[ip][wire-1] = offset + t_zero[ip][wire-1];

			    }
			  
			}
		      
		      else if ( ip == 0 && wire <=80)
			{
			  if (t_zero[ip][wire-1] == weighted_avg[ip])
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - weighted_avg[ip]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - weighted_avg[ip]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - weighted_avg[ip]);	  
			      t_zero_final[ip][wire-1] =  weighted_avg[ip];

			    }
			  else
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - t_zero[ip][wire-1]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - t_zero[ip][wire-1]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - t_zero[ip][wire-1]);
			      t_zero_final[ip][wire-1] =  t_zero[ip][wire-1];
			    }
			  
			}
		      
		      //apply tdc offset to plane 6
		      else if (ip== 6 && wire > 80)
			{
			  if ( t_zero[ip][wire-1] == weighted_avg[ip])
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - offset - weighted_avg[ip]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - offset - weighted_avg[ip]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - offset - weighted_avg[ip]);	     
			      t_zero_final[ip][wire-1] = offset + weighted_avg[ip];

			    }
			  
			  else
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - offset - t_zero[ip][wire-1]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - offset - t_zero[ip][wire-1]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - offset - t_zero[ip][wire-1]);
			      t_zero_final[ip][wire-1] = offset + t_zero[ip][wire-1];
			    }
			}
		      
		      else if (ip == 6 && wire <= 80)
			{
			  
			  if ( t_zero[ip][wire-1] == weighted_avg[ip])
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - weighted_avg[ip]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - weighted_avg[ip]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - weighted_avg[ip]);	  
			      t_zero_final[ip][wire-1] =  weighted_avg[ip];

			    }
			  else 
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - t_zero[ip][wire-1]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - t_zero[ip][wire-1]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - t_zero[ip][wire-1]);
			      t_zero_final[ip][wire-1] =  t_zero[ip][wire-1];
			    }		  
			  
			}
		      
		      else if ((ip == 4 || ip == 10) && wire > 48 && wire <65)
			{
			  if (t_zero[ip][wire-1] == weighted_avg[ip])
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - offset - weighted_avg[ip]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - offset - weighted_avg[ip]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - offset - weighted_avg[ip]);	  
			      t_zero_final[ip][wire-1] = offset + weighted_avg[ip];

			    }
			  else 
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k]  -offset - t_zero[ip][wire-1]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - offset - t_zero[ip][wire-1]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - offset - t_zero[ip][wire-1]);
			      t_zero_final[ip][wire-1] = offset + t_zero[ip][wire-1];
			    }
			  
			}
		      
		      else if (ip == 4 && (wire <=48 || wire >= 65 ))
			{
			  if (t_zero[ip][wire-1] == weighted_avg[ip])
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - weighted_avg[ip]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - weighted_avg[ip]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - weighted_avg[ip]);	  
			      t_zero_final[ip][wire-1] =  weighted_avg[ip];

			    }
			  else
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - t_zero[ip][wire-1]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - t_zero[ip][wire-1]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - t_zero[ip][wire-1]);
			      t_zero_final[ip][wire-1] =  t_zero[ip][wire-1];
			    }
			  
			}
		      
		      
		      else if (ip == 10 && (wire <= 48 || wire >= 65))
			{
			  if (t_zero[ip][wire-1] == weighted_avg[ip])
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - weighted_avg[ip]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - weighted_avg[ip]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - weighted_avg[ip]);	  
			      t_zero_final[ip][wire-1] =  weighted_avg[ip];

			    }
			  
			  else 
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - t_zero[ip][wire-1]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - t_zero[ip][wire-1]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - t_zero[ip][wire-1]);
			      t_zero_final[ip][wire-1] =  t_zero[ip][wire-1];
			    }
			  
			}
		      
		      else if (ip!=4 || ip!=0 || ip!=6 || ip!=10)
			{
			  
			  if (t_zero[ip][wire-1] == weighted_avg[ip])
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - weighted_avg[ip]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - weighted_avg[ip]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - weighted_avg[ip]);	  
			      t_zero_final[ip][wire-1] =  weighted_avg[ip];

			    }
			  else
			    {
			      //Fill corrected plane drift times 
			      plane_dt_corr[ip].Fill(drift_time[ip][k] - t_zero[ip][wire-1]); 
			      cell_dt_corr[ip][wire-1].Fill(drift_time[ip][k] - t_zero[ip][wire-1]);
			      dt_vs_wire_corr[ip].Fill(wire_num[ip][k], drift_time[ip][k] - t_zero[ip][wire-1]);
			      t_zero_final[ip][wire-1] =   t_zero[ip][wire-1];
			    }
			  
			}
		      
		    }  // end LOOP over number of hits
		  
		} //end if statement(require #of hits to be UNITY)
	  
	    
	    } //end loop over planes
	  
	} //end loop over PID cuts
    
    } //end loop over events
  
} // end loop over method

//_________________________________________________________________________________
void DC_calib::WriteLookUpTable()
{
  otxtfile_name = "./"+spec+"_DC_Log_"+std::to_string(run_NUM)+"/"+spectre+"dc_calib_"+std::to_string(run_NUM)+".param";
  out_txtFILE.open(otxtfile_name);
  Double_t t_offset_firstbin = 0.0;
  //Set headers for subsequent columns of data
  out_txtFILE << Form("; Lookup Table: RUN %d", run_NUM) << "\n";
  out_txtFILE << "; number of bins in time to distance lookup table" << "\n";
  out_txtFILE << Form(spectre+"driftbins = %d", TOTAL_BINS+1) << "\n";
  out_txtFILE << "; number of 1st bin in table in ns" << "\n";
  out_txtFILE << spectre+Form("drift1stbin=%f", t_offset_firstbin + 1.) << "\n";
  out_txtFILE << "; bin size in ns" << "\n";
  out_txtFILE << spectre+"driftbinsz=1" << "\n";
  
//Loop over each plane of hms/shms Drift Chambers (DC1 & DC2)

  for (int ip=0; ip<NPLANES; ip++){
   
    
    //Get bin corresponding to t0 = 0 ns
    bin_t0[ip] = plane_dt_corr[ip].GetXaxis()->FindBin(t_offset_firstbin);
   
    //Get final bin 
    bin_final[ip] = bin_t0[ip] + TOTAL_BINS;
   
    //Find total BIN Content over entire integration range
    binContent_TOTAL[ip] = 0.; //set counter to zero


    for (int bin = bin_t0[ip]; bin <= bin_final[ip]; bin ++ ) {
     
      bin_Content[ip] = plane_dt_corr[ip].GetBinContent(bin);
     
      binContent_TOTAL[ip] = bin_Content[ip] + binContent_TOTAL[ip];
     
      //   cout << "Bin: " << bin << endl;
      //   cout << "Content " << bin_Content[ip] << endl;
      //   cout << "Content SUM : " << binContent_TOTAL[ip] << endl;
    }
   
    TString headers = spectre+"wc" + plane_names[ip] + "fract=";      
    out_txtFILE << headers;	  
   
    //Calculate LookUp Value
   
    binSUM[ip] = 0.0;
    bin_count = 0;
   
    for (int bin = bin_t0[ip]; bin <= bin_final[ip]; bin++) {
     
      bin_Content[ip] = plane_dt_corr[ip].GetBinContent(bin);
      binSUM[ip] = binSUM[ip] + bin_Content[ip];
     
     
      lookup_value[ip] = binSUM[ip] / binContent_TOTAL[ip];
      bin_count = bin_count + 1;
     
      if (bin_count <= 16 ) {
	out_txtFILE << setprecision(5) << lookup_value[ip] << fixed << ",";
      }
     
      else if (bin_count >16 && bin_count <= TOTAL_BINS) {
	out_txtFILE << setprecision(5) << lookup_value[ip] << ((bin_count+1) % 20 ? "," : "\n") << fixed; 
      }
      else {
	out_txtFILE  << setprecision(5) << lookup_value[ip] <<  fixed << endl;	  
      }
     
    } //END LOOP OVER plane drift time BINS

  } //END LOOP OVER PLANES                     

  out_txtFILE.close();

}
